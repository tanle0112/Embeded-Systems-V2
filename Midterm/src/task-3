#include <Arduino.h>
#include <Wire.h>
#include <LiquidCrystal_I2C.h>
#include <DHT20.h>
#include <math.h>
#ifndef SDA_PIN
#define SDA_PIN 8
#endif
#ifndef SCL_PIN
#define SCL_PIN 9
#endif

#define LCD_ADDR 0x21   // địa chỉ LCD 0x21
#define LCD_COLS 16
#define LCD_ROWS 2
#define TEMP_WARN        30.0f
#define TEMP_CRITICAL    36.0f
#define HUMIDITY_MOIST   40.0f
#define HUMIDITY_WET     70.0f
#define SENSOR_DELAY_MS  1000

static SemaphoreHandle_t i2cMutex      = nullptr;  // khóa I2C chung cho LCD & DHT20
static SemaphoreHandle_t xNewSampleSem = nullptr;  // báo có mẫu mới
static SemaphoreHandle_t xStateSem     = nullptr;  // báo đổi trạng thái
static QueueHandle_t     sensorQueue   = nullptr;  // hàng đợi dữ liệu

static DHT20 dht20; //sensor dht20 & lcd 
static LiquidCrystal_I2C lcd(LCD_ADDR, LCD_COLS, LCD_ROWS);

typedef struct {
  float temperature;
  float humidity;
  int   alarmState; // 0: Normal, 1: Warning, 2: Critical
} SensorData_t;

//scan 
static void i2cScanOnce() {
  Serial.println("[I2C] Scanning...");
  uint8_t count = 0;
  for (uint8_t address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    uint8_t error = Wire.endTransmission();
    if (error == 0) {
      Serial.print("  Found device at 0x");
      if (address < 16) Serial.print('0');
      Serial.println(address, HEX);
      count++;
    }
  }
  if (count == 0) Serial.println("  No I2C devices found!");
}

//dht20 task
static void SensorTask(void *pvParameters)
{
  (void)pvParameters;
  int prevState = -1;

  for (;;) {
    float t = NAN, h = NAN;

    if (xSemaphoreTake(i2cMutex, pdMS_TO_TICKS(500)) == pdTRUE) {
      if (dht20.read() == 0) {      // 0 = OK (RobTillaart/DHT20)
        t = dht20.getTemperature();
        h = dht20.getHumidity();
      }
      xSemaphoreGive(i2cMutex);
    } else {
      Serial.println("[SensorTask] I2C mutex timeout");
    }

    if (!isnan(t) && !isnan(h)) {
      int state = 0; // Normal
      if (t > TEMP_CRITICAL && h < HUMIDITY_MOIST) {
        state = 2;   // Critical
      } else if ((t >= TEMP_WARN && t <= TEMP_CRITICAL) &&
                 (h >= HUMIDITY_MOIST && h <= HUMIDITY_WET)) {
        state = 1;   // Warning
      }

      SensorData_t data = { t, h, state };
      xQueueOverwrite(sensorQueue, &data);
      xSemaphoreGive(xNewSampleSem);

      if (state != prevState) {
        xSemaphoreGive(xStateSem); // đổi trạng thái → báo DisplayTask
        prevState = state;
      }

      Serial.printf("[SensorTask] T:%.2fC  H:%.2f%%  state:%d\n", t, h, state);
    } else {
      Serial.println("[SensorTask] Sensor read failed (NaN)");
      xSemaphoreGive(xNewSampleSem);
    }

    vTaskDelay(pdMS_TO_TICKS(SENSOR_DELAY_MS));
  }
}


static void printHeader(int alarmState, uint8_t offset)
{
  const char *base = "LCD screen display..";
  const char *sfx  = (alarmState == 2) ? " C" : (alarmState == 1) ? " W" : " N";

  char line[40] = {0};
  snprintf(line, sizeof(line), "%s%s   ", base, sfx); // thêm vài space cho mượt
  size_t L = strlen(line);
  if (L == 0) return;
  offset %= L;

  char view[17] = {0};
  for (int i = 0; i < LCD_COLS; ++i) view[i] = line[(offset + i) % L];
  view[16] = '\0';

  lcd.setCursor(0, 0);
  lcd.print(view);
}

/* ===================== DISPLAY TASK ===================== */
static void DisplayTask(void *pvParameters)
{
  (void)pvParameters;

  SensorData_t data, prev = { -1000.0f, -1000.0f, -1 };
  uint32_t lastTick = millis();
  uint8_t marqueeOffset = 0;
  bool blinkFlag = false;

  for (;;) {
    xSemaphoreTake(xNewSampleSem, pdMS_TO_TICKS(100));
    if (uxSemaphoreGetCount(xStateSem) > 0) xSemaphoreTake(xStateSem, 0);

    if (xQueuePeek(sensorQueue, &data, 0) == pdTRUE) {
      bool needUpdate =
        fabs(data.temperature - prev.temperature) > 0.1f ||
        fabs(data.humidity    - prev.humidity)    > 0.1f ||
        data.alarmState != prev.alarmState ||
        (millis() - lastTick) > 350; // nhịp cuộn marquee

      if (needUpdate) {
        if (xSemaphoreTake(i2cMutex, pdMS_TO_TICKS(500)) == pdTRUE) {
    
          printHeader(data.alarmState, marqueeOffset++);

          lcd.setCursor(0, 1);
          char line[17];
          snprintf(line, sizeof(line), "T:%4.1fC H:%4.1f%%", data.temperature, data.humidity);
          lcd.print(line);

          if (data.alarmState == 0) {
            lcd.backlight();                // Normal: bật ổn định
          } else if (data.alarmState == 1) {
            blinkFlag = !blinkFlag;         // Warning: nháy chậm
            if (blinkFlag) lcd.backlight(); else lcd.noBacklight();
          } else {
            lcd.backlight();                // Critical: bật + chớp "!"
            lcd.setCursor(15, 1);
            lcd.print(blinkFlag ? "!" : " ");
            blinkFlag = !blinkFlag;
          }

          xSemaphoreGive(i2cMutex);
        } else {
          Serial.println("[DisplayTask] I2C mutex timeout");
        }
        prev = data;
        lastTick = millis();
      }
    }

    vTaskDelay(pdMS_TO_TICKS(50));
  }
}

void setup()
{
  Serial.begin(115200);
  delay(300);

  Wire.begin(SDA_PIN, SCL_PIN);
  i2cScanOnce(); // debug: nên thấy 0x21

  // LCD
  lcd.begin();                // nếu lib bạn yêu cầu tham số: lcd.begin(LCD_COLS, LCD_ROWS);
  lcd.backlight();
  lcd.clear();
  lcd.setCursor(0, 0);
  lcd.print("System Booting...");
  lcd.setCursor(0, 1);
  lcd.print("Please wait...");

  // DHT20
  if (!dht20.begin()) {
    Serial.println("[Boot] DHT20 begin failed!");
  }

  // RTOS objects
  i2cMutex      = xSemaphoreCreateMutex();
  xNewSampleSem = xSemaphoreCreateBinary();
  xStateSem     = xSemaphoreCreateBinary();
  sensorQueue   = xQueueCreate(1, sizeof(SensorData_t));

  if (!i2cMutex || !xNewSampleSem || !xStateSem || !sensorQueue) {
    Serial.println("[Boot] RTOS objects create failed!");
    lcd.clear(); lcd.print("RTOS Boot Fail!");
    while (true) vTaskDelay(pdMS_TO_TICKS(1000));
  }

  // Tasks
  BaseType_t r1 = xTaskCreatePinnedToCore(SensorTask,  "SensorTask",  4096, NULL, 2, NULL, 1);
  BaseType_t r2 = xTaskCreatePinnedToCore(DisplayTask, "DisplayTask", 4096, NULL, 1, NULL, 1);

  if (r1 != pdPASS || r2 != pdPASS) {
    Serial.println("[Boot] Task create failed!");
    lcd.clear(); lcd.print("Task Create Err");
    while (true) vTaskDelay(pdMS_TO_TICKS(1000));
  }

  Serial.println("Temperature/Humidity monitor started.");
}

void loop() {
  // Không dùng loop – mọi thứ chạy trong FreeRTOS tasks
}
